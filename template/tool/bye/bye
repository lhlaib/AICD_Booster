#!/bin/bash

# ============================================================
#  Remote Desktop Session Manager (Visual Interactive Edition)
#  Platform: Rocky Linux 8
# ============================================================

# --- Colors & Tput ---
# Using tput for better terminal control
BOLD=$(tput bold)
REV=$(tput rev) # Reverse video (Highlight)
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Hide cursor during execution for cleaner UI
trap "tput cnorm; exit" INT TERM EXIT

# --- Helper: Header ---
function show_header() {
    clear
    echo -e "${BLUE}======================================================${NC}"
    echo -e "${BOLD}        REMOTE DESKTOP SESSION MANAGER        ${NC}"
    echo -e "${BLUE}======================================================${NC}"
    if [ -n "$1" ]; then
        echo -e "  ${MAGENTA}Mode: $1${NC}"
    fi
}

# --- Helper: Pause ---
function pause_screen() {
    echo ""
    echo -e "${WHITE}  Press any key to continue...${NC}"
    read -n 1 -s
}

# --- Helper: Help Menu ---
function show_help() {
    clear
    echo -e "${BLUE}======================================================${NC}"
    echo -e "${BOLD}                  HELP & INSTRUCTIONS                 ${NC}"
    echo -e "${BLUE}======================================================${NC}"
    echo ""
    echo -e "  ${BOLD}1. Force Logout:${NC}"
    echo -e "     Instantly kills ALL your processes (Simulations, Desktop, Background jobs)."
    echo -e "     ${RED}Use this if your screen is frozen or you cannot log in.${NC}"
    echo ""
    echo -e "  ${BOLD}2. Task Manager:${NC}"
    echo -e "     A visual tool to kill specific stuck programs."
    echo -e "     ${CYAN}[Arrow Up/Down]${NC} Select program."
    echo -e "     ${CYAN}[Arrow Left/Right]${NC} Change pages."
    echo -e "     ${CYAN}[Enter]${NC} Kill selected program."
    echo ""
    echo -e "  ${BOLD}3. Disconnect Only:${NC}"
    echo -e "     Shows instructions on how to close the view without killing simulations."
    echo ""
    echo -e "  ${BOLD}Admin Features:${NC}"
    echo -e "     Admins can select a user to perform these actions on their behalf."
    echo -e "     'Restart XRDP' is a global reset for the entire server."
    echo ""
    echo -e "${WHITE}  Press any key to return...${NC}"
    read -n 1 -s
}

# ============================================================
#  CORE: VISUAL TASK MANAGER
#  Supports: Arrow Keys, Pagination, Enter to Kill
# ============================================================
function visual_task_manager() {
    local target_user=$1
    local role=$2
    local page_offset=0
    local page_size=10
    local selected_index=0 # 0 to (page_size - 1)
    
    # Hide cursor
    tput civis 

    while true; do
        # 1. Fetch Data
        # Format: PID, %CPU, %MEM, TIME, COMMAND
        mapfile -t PROC_LIST < <(ps -u "$target_user" -o pid,%cpu,%mem,time,comm --sort=-%cpu --no-headers | grep -vE "ps|grep|bash|sshd|sftp|bye")
        local total_procs=${#PROC_LIST[@]}
        
        # 2. Draw UI
        show_header "$role - Task Manager"
        echo -e "  Target User: ${CYAN}${BOLD}$target_user${NC}"
        echo -e "  ${YELLOW}Use Arrow Keys (↑/↓) to select, (←/→) for pages, [Enter] to kill.${NC}"
        echo ""
        echo -e "${BOLD}   PID     %CPU   %MEM   TIME      COMMAND${NC}"
        echo -e "${BLUE}  --------------------------------------------------${NC}"

        local count=0
        local actual_page_count=0
        
        for (( i=$page_offset; i<$page_offset+$page_size; i++ )); do
            if [ $i -ge $total_procs ]; then break; fi
            
            line=${PROC_LIST[$i]}
            pid=$(echo $line | awk '{print $1}')
            cpu=$(echo $line | awk '{print $2}')
            mem=$(echo $line | awk '{print $3}')
            time=$(echo $line | awk '{print $4}')
            comm=$(echo $line | awk '{print $5}')
            
            # Visual Selection Logic
            if [ $count -eq $selected_index ]; then
                # Highlighted Row
                printf "${REV}   %-7s %-6s %-6s %-9s %-15s ${NC}\n" "$pid" "$cpu" "$mem" "$time" "$comm"
            else
                # Normal Row
                printf "   %-7s %-6s %-6s %-9s %-15s \n" "$pid" "$cpu" "$mem" "$time" "$comm"
            fi
            ((count++))
            ((actual_page_count++))
        done

        # Fill empty lines if page is not full to keep UI stable
        for (( j=$count; j<$page_size; j++ )); do
            echo ""
        done

        echo -e "${BLUE}  --------------------------------------------------${NC}"
        echo -e "  Page: $(( (page_offset/page_size) + 1 )) | Total: $total_procs | ${BOLD}q${NC}: Back"

        # 3. Input Handling (Single Key & Arrow Keys)
        # Read 1 byte first
        read -rsn1 input
        
        # Handle Arrow Keys (Escape Sequences)
        if [[ "$input" == $'\x1b' ]]; then
            read -rsn2 -t 0.1 input # Read next 2 bytes
            case "$input" in
                '[A') # UP
                    if [ $selected_index -gt 0 ]; then
                        ((selected_index--))
                    fi
                    ;;
                '[B') # DOWN
                    if [ $selected_index -lt $((actual_page_count - 1)) ]; then
                        ((selected_index++))
                    fi
                    ;;
                '[C') # RIGHT (Next Page)
                    if [ $((page_offset + page_size)) -lt $total_procs ]; then
                        page_offset=$((page_offset + page_size))
                        selected_index=0
                    fi
                    ;;
                '[D') # LEFT (Prev Page)
                    if [ $page_offset -gt 0 ]; then
                        page_offset=$((page_offset - page_size))
                        selected_index=0
                    fi
                    ;;
            esac
        # Handle Enter Key (Kill Action)
        elif [[ "$input" == "" ]]; then
            real_index=$((page_offset + selected_index))
            if [ $real_index -lt $total_procs ]; then
                target_line=${PROC_LIST[$real_index]}
                target_pid=$(echo $target_line | awk '{print $1}')
                target_name=$(echo $target_line | awk '{print $5}')
                
                # Confirm Dialog
                tput cnorm # Show cursor for prompt
                echo ""
                echo -e "  ${RED}${BOLD}CONFIRM KILL:${NC} $target_name (PID: $target_pid)"
                echo -ne "  Are you sure? (y/n): "
                read -n 1 -s confirm_key
                
                if [[ "$confirm_key" == "y" || "$confirm_key" == "Y" ]]; then
                    kill -9 "$target_pid" 2>/dev/null
                    echo -e "\n  ${RED}[*] Killed $target_name.${NC}"
                    sleep 0.5
                else
                    echo -e "\n  ${GREEN}[!] Cancelled.${NC}"
                    sleep 0.5
                fi
                tput civis # Hide cursor again
            fi
        # Handle Quit
        elif [[ "$input" == "q" ]]; then
            tput cnorm
            break
        fi
    done
    tput cnorm
}

# ============================================================
#  ACTION: FORCE LOGOUT
# ============================================================
function action_force_logout() {
    local user=$1
    echo ""
    echo -e "${RED}  >>> Force Logout for ${NC}${CYAN}$user${NC}"
    echo -e "${YELLOW}  [WARNING] This will kill ALL processes ${NC}"
    echo -e "${YELLOW}   Remember to \"save\" your work before proceeding!${NC}"
    echo -ne "${BOLD}  Are you sure to log out? (y/n): ${NC}"
    read -n 1 -s key
    if [[ "$key" == "y" || "$key" == "Y" ]]; then
        echo -e "\n  ${RED}[*] Terminating Session...${NC}"
        pkill -TERM -u "$TARGET_USER" 2>/dev/null
        sleep 1
        pkill -KILL -u "$user" 2>/dev/null
        loginctl terminate-user "$user" 2>/dev/null
        echo -e "  ${GREEN}[✓] Done.${NC}"
        sleep 1
        if [ "$AM_I_ROOT" = false ]; then exit 0; fi # Exit if user
    else
        echo -e "\n  ${GREEN}[!] Cancelled.${NC}"
        sleep 1
    fi
}

# ============================================================
#  MENUS
# ============================================================

function menu_manage_user() {
    local target_user=$1
    local role=$2

    while true; do
        show_header "$role"
        echo -e "  Target User: ${CYAN}${BOLD}$target_user${NC}"
        echo ""
        echo -e "  ${BOLD}Select an action:${NC}"
        echo -e "  ${CYAN}1)${NC} ${RED}Force Logout${NC} (Kill All)"
        echo -e "  ${CYAN}2)${NC} ${YELLOW}Task Manager${NC} (Visual Process Killer)"
        echo -e "  ${CYAN}3)${NC} ${GREEN}Disconnect Only${NC} (Instructions)"
        echo -e "  ${CYAN}h)${NC} Help / Instructions"
        echo -e "  ${CYAN}q)${NC} Back"
        echo -e "  ${CYAN}x)${NC} Exit Program"
        echo ""
        echo -ne "${BOLD}  Input > ${NC}"
        
        read -n 1 -s option
        
        case "$option" in
            1) action_force_logout "$target_user" ;;
            2) visual_task_manager "$target_user" "$role" ;;
            3) 
                echo -e "\n\n  ${GREEN}[INFO]${NC} To disconnect but keep programs running:"
                echo -e "  Simply close your browser tab or window (X)."
                echo -e "  ${RED}DO NOT${NC} click 'Log Out' in the Start Menu."
                pause_screen 
                ;;
            h|H) show_help ;;
            q|Q) return ;; 
            x|X) clear; exit 0 ;;
            *) ;;
        esac
    done
}

function menu_admin_main() {
    while true; do
        show_header "ADMINISTRATOR"
        echo -e "  ${BOLD}Select an operation:${NC}"
        echo -e "  ${CYAN}1)${NC} ${YELLOW}Manage a Specific User${NC}"
        echo -e "  ${CYAN}2)${NC} ${RED}Restart XRDP Service (Global Reset)${NC}"
        echo -e "  ${CYAN}h)${NC} Help"
        echo -e "  ${CYAN}q)${NC} Back"
        echo -e "  ${CYAN}x)${NC} Exit"
        echo ""
        echo -ne "${BOLD}  Input > ${NC}"
        
        read -n 1 -s option

        case "$option" in
            1)
                echo ""
                echo -ne "${YELLOW}  Enter username > ${NC}"
                tput cnorm
                read target_input
                tput civis
                if id "$target_input" &>/dev/null; then
                    menu_manage_user "$target_input" "ADMIN"
                else
                    echo -e "${RED}  [!] User not found.${NC}"
                    sleep 1
                fi
                ;;
            2)
                echo ""
                echo -e "${RED}  [!] CRITICAL: This disconnects EVERYONE on the server.${NC}"
                echo -ne "${BOLD}  Type 'y' to confirm: ${NC}"
                read -n 1 -s key
                if [[ "$key" == "y" || "$key" == "Y" ]]; then
                    echo -e "\n  ${YELLOW}[*] Restarting XRDP...${NC}"
                    systemctl restart xrdp
                    echo -e "  ${GREEN}[✓] Done.${NC}"
                    pause_screen
                else
                    echo -e "\n  Cancelled."
                    sleep 0.5
                fi
                ;;
            h|H) show_help ;;
            q|Q) return ;;
            x|X) clear; exit 0 ;;
            *) ;;
        esac
    done
}

# ============================================================
#  MAIN ENTRY POINT
# ============================================================

# Detect Role
AM_I_ROOT=false
if [ "$EUID" -eq 0 ]; then
    AM_I_ROOT=true
fi

# Ensure cursor is visible on exit
trap "tput cnorm; exit" INT TERM EXIT

tput civis # Hide cursor initially for menu

if [ "$AM_I_ROOT" = true ]; then
    menu_admin_main
else
    # Student Mode directly enters Manage Menu for themselves
    CURRENT_USER=$(whoami)
    menu_manage_user "$CURRENT_USER" "USER"
fi
